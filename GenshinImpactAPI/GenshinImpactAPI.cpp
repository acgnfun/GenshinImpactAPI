#pragma warning(disable: 4996)

#include <Windows.h>
#include "GenshinImpactAPI.h"
#include <bit7z/bit7z.hpp>
#include <afc/ShortCut.h>
#include <afc/StringProc.h>
#include <afc/PathProc.h>
#include <hpatchz.h>
#include <fstream>

// Do not change!!!
#define DEFAULT_GAMEINFO_JSON_STRING	R"({"game":{"entry":"","language":[],"path":"","server":"","status":false,"version":""},"sign":"The configuration file is automatically generated by Genshin Impact API"})"
#define RIURL_CNREL_0	"https://sdk-static.mihoyo.com/hk4e_cn/mdk/launcher/api/resource?channel_id=1&key=eYd89JmJ&launcher_id=18&sub_channel_id=1"
#define RIURL_CNREL_1	"https://sdk-static.mihoyo.com/hk4e_cn/mdk/launcher/api/resource?channel_id=14&key=KAtdSsoQ&launcher_id=17&sub_channel_id=0"
#define RIURL_OSREL		"https://hk4e-launcher-static.hoyoverse.com/hk4e_global/mdk/launcher/api/resource?channel_id=1&key=gcStgarh&launcher_id=10&sub_channel_id=0"
#define RIURL_CNRELW_0	L"https://sdk-static.mihoyo.com/hk4e_cn/mdk/launcher/api/resource?channel_id=1&key=eYd89JmJ&launcher_id=18&sub_channel_id=1"
#define RIURL_CNRELW_1	L"https://sdk-static.mihoyo.com/hk4e_cn/mdk/launcher/api/resource?channel_id=14&key=KAtdSsoQ&launcher_id=17&sub_channel_id=0"
#define RIURL_OSRELW	L"https://hk4e-launcher-static.hoyoverse.com/hk4e_global/mdk/launcher/api/resource?channel_id=1&key=gcStgarh&launcher_id=10&sub_channel_id=0"
// Do not change!!!

#define SHORTCUT_NAME_NO_SUFFIX			"原神"

static std::string urlname(std::string url)
{
	return url.substr(url.find_last_of('/') + 1);
}

GIAPI::Manager::Manager()
{
	ResourceIndexStat = false;
	LocalMetadataStat = false;
}

GIAPI::Manager::~Manager()
{
	// FlushMetadata();
	// 这里不能使用FlushMetadata方法，因为在此析构函数执行前，FlushMetadata所需要的LocalMetadata对象已经被析构
	// LocalMetadata对象实际是一个空对象，FlushMetadata会将此空对象写入硬盘，导致Metadata文件内容被错误删除
	// 应该在每一个对LocalMetadata对象的更改行为之后使用FlushMetadata，而不是在析构函数中调用
}

GIAPI::ErrorCode GIAPI::Manager::ResourceIndexUrl(Server ServerId, string& ReturnUrl) const
{
	switch (ServerId)
	{
	case GIAPI::CNREL_OFFICIAL:
		ReturnUrl = RIURL_CNREL_0;
		break;
	case GIAPI::CNREL_BILIBILI:
		ReturnUrl = RIURL_CNREL_1;
		break;
	case GIAPI::OSREL_GLOBAL:
		ReturnUrl = RIURL_OSREL;
		break;
	default:
		ReturnUrl.clear();
		return ServerIdNotSet;
		break;
	}
	return Success;
}

GIAPI::ErrorCode GIAPI::Manager::LoadResourceIndex(path ResourcePath)
{
	ResourcePath = std::filesystem::absolute(ResourcePath);
	std::fstream file(ResourcePath, std::ios::in | std::ios::binary);
	if (!file.is_open()) return UnknownError;
	ResourceIndexStat = false;
	bool ret = true;
	try { ResourceIndex.clear(); file >> ResourceIndex; }
	catch (...) { ret = false; }
	file.close();
	if (!ret) return UnknownError;
	try { if (!ResourceIndex["data"]["game"]["latest"]["entry"].is_string()) { ret = false; ResourceIndex.clear(); } }
	catch (...) { ret = false; ResourceIndex.clear(); }
	if (!ret) return UnknownError;
	ResourceIndexStat = true;
	return Success;
}

GIAPI::ErrorCode GIAPI::Manager::LoadLocalMetadata(path MetadataPath)
{
	MetadataPath = std::filesystem::absolute(MetadataPath);
	std::fstream file(MetadataPath, std::ios::in | std::ios::binary);
	if (file.is_open())
	{
		bool ret = true;
		LocalMetadataStat = false;
		try { LocalMetadata.clear(); file >> LocalMetadata; }
		catch (...) { ret = false; }
		file.close();
		if (!ret) return UnknownError;
		try { if (!LocalMetadata["game"]["entry"].is_string()) { ret = false; LocalMetadata.clear(); } }
		catch (...) { ret = false; LocalMetadata.clear(); }
		if (!ret)
		{
			LocalMetadata.clear();
			LocalMetadata.parse(DEFAULT_GAMEINFO_JSON_STRING);
		}
		this->MetadataPath = MetadataPath;
		LocalMetadataStat = true;
		//FlushMetadata();加载Metadata时不需要Flush，以节省硬碟寿命
		return Success;
	}
	if (std::filesystem::exists(MetadataPath)) return UnknownError;
	//std::filesystem::create_directories(std::filesystem::absolute(std::filesystem::path(Path)).parent_path());
	file.open(MetadataPath, std::ios::out | std::ios::binary | std::ios::trunc);
	if (!file.is_open()) { return UnknownError; }
	LocalMetadataStat = false;
	LocalMetadata.clear();
	LocalMetadata.parse(DEFAULT_GAMEINFO_JSON_STRING);
	file.write(DEFAULT_GAMEINFO_JSON_STRING, strlen(DEFAULT_GAMEINFO_JSON_STRING));
	file.close();
	this->MetadataPath = MetadataPath;
	LocalMetadataStat = true;
	return Success;
}

GIAPI::ErrorCode GIAPI::Manager::GetLocalGameServer(Server& ReturnServerId) const
{
	if (!LocalMetadataStat) return LocalMetadataNotLoaded;
	if (!StatInstalled()) return NotInstalled;
	try
	{
		string serverId = LocalMetadata["game"]["server"];
		if (serverId == ("cnrel_0"))
			ReturnServerId = CNREL_OFFICIAL;
		else if (serverId == "cnrel_1")
			ReturnServerId = CNREL_BILIBILI;
		else if (serverId == "osrel")
			ReturnServerId = OSREL_GLOBAL;
		else
		{
			ReturnServerId = UNKNOWN;
			throw "unknown server type string.";
		}
	}
	catch (...) { return UnknownError; }
	return Success;
}

GIAPI::ErrorCode GIAPI::Manager::GetInstallPackageUrl(int Language, urllist& ReturnList) const
{
	if (!ResourceIndexStat) return ResourceIndexNotLoaded;
	ReturnList.clear();
	urlobj tempobj;
	bool loaded = false;
	try
	{
		for (size_t i = 0; i < ResourceIndex["data"]["game"]["latest"]["segments"].size(); i++)
		{
			tempobj.url = ResourceIndex["data"]["game"]["latest"]["segments"][i]["path"];
			tempobj.md5 = ResourceIndex["data"]["game"]["latest"]["segments"][i]["md5"];
			tempobj.filename = urlname(tempobj.url);
			ReturnList.push_back(tempobj);
		}
		for (size_t i = 0; i < ResourceIndex["data"]["game"]["latest"]["voice_packs"].size(); i++)
		{
			loaded = false;
			if ((Language & zh_CN) && ResourceIndex["data"]["game"]["latest"]["voice_packs"][i]["language"] == "zh-cn")
			{
				tempobj.url = ResourceIndex["data"]["game"]["latest"]["voice_packs"][i]["path"];
				tempobj.md5 = ResourceIndex["data"]["game"]["latest"]["voice_packs"][i]["md5"];
				tempobj.filename = urlname(tempobj.url);
				loaded = true;
			}
			else if ((Language & en_US) && ResourceIndex["data"]["game"]["latest"]["voice_packs"][i]["language"] == "en-us")
			{
				tempobj.url = ResourceIndex["data"]["game"]["latest"]["voice_packs"][i]["path"];
				tempobj.md5 = ResourceIndex["data"]["game"]["latest"]["voice_packs"][i]["md5"];
				tempobj.filename = urlname(tempobj.url);
				loaded = true;
			}
			else if ((Language & ja_JP) && ResourceIndex["data"]["game"]["latest"]["voice_packs"][i]["language"] == "ja-jp")
			{
				tempobj.url = ResourceIndex["data"]["game"]["latest"]["voice_packs"][i]["path"];
				tempobj.md5 = ResourceIndex["data"]["game"]["latest"]["voice_packs"][i]["md5"];
				tempobj.filename = urlname(tempobj.url);
				loaded = true;
			}
			else if ((Language & ko_KR) && ResourceIndex["data"]["game"]["latest"]["voice_packs"][i]["language"] == "ko-kr")
			{
				tempobj.url = ResourceIndex["data"]["game"]["latest"]["voice_packs"][i]["path"];
				tempobj.md5 = ResourceIndex["data"]["game"]["latest"]["voice_packs"][i]["md5"];
				tempobj.filename = urlname(tempobj.url);
				loaded = true;
			}
			if (loaded) ReturnList.push_back(tempobj);
		}
		return Success;
	}
	catch (...) {}
	return UnknownError;
}

GIAPI::ErrorCode GIAPI::Manager::GetPreInstallPackageUrl(int Language, urllist& ReturnList) const
{
	if (!ResourceIndexStat) return ResourceIndexNotLoaded;
	if (!StatPreDownload()) return PredownloadNotSupported;
	ReturnList.clear();
	urlobj tempobj;
	bool loaded = false;
	try
	{
		for (size_t i = 0; i < ResourceIndex["data"]["pre_download_game"]["latest"]["segments"].size(); i++)
		{
			tempobj.url = ResourceIndex["data"]["pre_download_game"]["latest"]["segments"][i]["path"];
			tempobj.md5 = ResourceIndex["data"]["pre_download_game"]["latest"]["segments"][i]["md5"];
			tempobj.filename = urlname(tempobj.url);
			ReturnList.push_back(tempobj);
		}
		for (size_t i = 0; i < ResourceIndex["data"]["pre_download_game"]["latest"]["voice_packs"].size(); i++)
		{
			loaded = false;
			if ((Language & zh_CN) && ResourceIndex["data"]["pre_download_game"]["latest"]["voice_packs"][i]["language"] == "zh-cn")
			{
				tempobj.url = ResourceIndex["data"]["pre_download_game"]["latest"]["voice_packs"][i]["path"];
				tempobj.md5 = ResourceIndex["data"]["pre_download_game"]["latest"]["voice_packs"][i]["md5"];
				tempobj.filename = urlname(tempobj.url);
				loaded = true;
			}
			else if ((Language & en_US) && ResourceIndex["data"]["pre_download_game"]["latest"]["voice_packs"][i]["language"] == "en-us")
			{
				tempobj.url = ResourceIndex["data"]["pre_download_game"]["latest"]["voice_packs"][i]["path"];
				tempobj.md5 = ResourceIndex["data"]["pre_download_game"]["latest"]["voice_packs"][i]["md5"];
				tempobj.filename = urlname(tempobj.url);
				loaded = true;
			}
			else if ((Language & ja_JP) && ResourceIndex["data"]["pre_download_game"]["latest"]["voice_packs"][i]["language"] == "ja-jp")
			{
				tempobj.url = ResourceIndex["data"]["pre_download_game"]["latest"]["voice_packs"][i]["path"];
				tempobj.md5 = ResourceIndex["data"]["pre_download_game"]["latest"]["voice_packs"][i]["md5"];
				tempobj.filename = urlname(tempobj.url);
				loaded = true;
			}
			else if ((Language & ko_KR) && ResourceIndex["data"]["pre_download_game"]["latest"]["voice_packs"][i]["language"] == "ko-kr")
			{
				tempobj.url = ResourceIndex["data"]["pre_download_game"]["latest"]["voice_packs"][i]["path"];
				tempobj.md5 = ResourceIndex["data"]["pre_download_game"]["latest"]["voice_packs"][i]["md5"];
				tempobj.filename = urlname(tempobj.url);
				loaded = true;
			}
			if (loaded) ReturnList.push_back(tempobj);
		}
		return Success;
	}
	catch (...) {}
	return UnknownError;
}

GIAPI::ErrorCode GIAPI::Manager::GetUpdatePackageUrl(urllist& ReturnList) const
{
	if (!ResourceIndexStat) return ResourceIndexNotLoaded;
	if (!StatInstalled()) return NotInstalled;
	if (StatLatest()) return AlreadyLatest;
	// Test updateable.
	const nlohmann::json* __diff = nullptr;
	std::string temp1, temp2;
	try
	{
		bool Accessable = false;
		for (size_t i = 0; i < ResourceIndex["data"]["game"]["diffs"].size(); i++)
		{
			//std::cout << _ArchiveInfo["data"]["game"]["diffs"][i] << std::endl;
			temp1 = ResourceIndex["data"]["game"]["diffs"][i]["version"];
			temp2 = LocalMetadata["game"]["version"];
			if (temp1 == temp2)
			{
				Accessable = true;
				__diff = &ResourceIndex["data"]["game"]["diffs"][i];
				break;
			}
		}
		if (!Accessable) return NeedReinstall;
	}
	catch (...) { return UnknownError; }
	const nlohmann::json& Diff = *__diff;
	//
	ReturnList.clear();
	int Language = 0;
	try
	{
		for (size_t i = 0; i < LocalMetadata["game"]["language"].size(); i++)
			if (LocalMetadata["game"]["language"][i] == "zh-cn") Language |= zh_CN;
			else if (LocalMetadata["game"]["language"][i] == "en-us") Language |= en_US;
			else if (LocalMetadata["game"]["language"][i] == "ja-jp") Language |= ja_JP;
			else if (LocalMetadata["game"]["language"][i] == "ko-kr") Language |= ko_KR;
	}
	catch (...) {}
	if (Language == 0) return UnknownError;
	urlobj tempobj;
	bool loaded = false;
	try
	{
		tempobj.url = Diff["path"];
		tempobj.md5 = Diff["md5"];
		tempobj.filename = urlname(tempobj.url);
		ReturnList.push_back(tempobj);
		for (size_t i = 0; i < Diff["voice_packs"].size(); i++)
		{
			loaded = false;
			if ((Language & zh_CN) && Diff["voice_packs"][i]["language"] == "zh-cn")
			{
				tempobj.url = Diff["voice_packs"][i]["path"];
				tempobj.md5 = Diff["voice_packs"][i]["md5"];
				tempobj.filename = urlname(tempobj.url);
				loaded = true;
			}
			else if ((Language & en_US) && Diff["voice_packs"][i]["language"] == "en-us")
			{
				tempobj.url = Diff["voice_packs"][i]["path"];
				tempobj.md5 = Diff["voice_packs"][i]["md5"];
				tempobj.filename = urlname(tempobj.url);
				loaded = true;
			}
			else if ((Language & ja_JP) && Diff["voice_packs"][i]["language"] == "ja-jp")
			{
				tempobj.url = Diff["voice_packs"][i]["path"];
				tempobj.md5 = Diff["voice_packs"][i]["md5"];
				tempobj.filename = urlname(tempobj.url);
				loaded = true;
			}
			else if ((Language & ko_KR) && Diff["voice_packs"][i]["language"] == "ko-kr")
			{
				tempobj.url = Diff["voice_packs"][i]["path"];
				tempobj.md5 = Diff["voice_packs"][i]["md5"];
				tempobj.filename = urlname(tempobj.url);
				loaded = true;
			}
			if (loaded) ReturnList.push_back(tempobj);
		}
		return Success;
	}
	catch (...) {}
	return UnknownError;
}

GIAPI::ErrorCode GIAPI::Manager::GetPreUpdatePackageUrl(urllist& ReturnList) const
{
	if (!ResourceIndexStat) return ResourceIndexNotLoaded;
	if (!StatPreDownload()) return PredownloadNotSupported;
	if (!StatInstalled()) return NotInstalled;
	if (StatLatest(true)) return AlreadyLatest;
	// Test updateable.
	const nlohmann::json* __diff = nullptr;
	std::string temp1, temp2;
	try
	{
		bool Accessable = false;
		for (size_t i = 0; i < ResourceIndex["data"]["pre_download_game"]["diffs"].size(); i++)
		{
			//std::cout << _ArchiveInfo["data"]["game"]["diffs"][i] << std::endl;
			temp1 = ResourceIndex["data"]["pre_download_game"]["diffs"][i]["version"];
			temp2 = LocalMetadata["game"]["version"];
			if (temp1 == temp2)
			{
				Accessable = true;
				__diff = &ResourceIndex["data"]["pre_download_game"]["diffs"][i];
				break;
			}
		}
		if (!Accessable) return NeedReinstall;
	}
	catch (...) { return UnknownError; }
	const nlohmann::json& Diff = *__diff;
	//
	ReturnList.clear();
	int Language = 0;
	try
	{
		for (size_t i = 0; i < LocalMetadata["game"]["language"].size(); i++)
			if (LocalMetadata["game"]["language"][i] == "zh-cn") Language |= zh_CN;
			else if (LocalMetadata["game"]["language"][i] == "en-us") Language |= en_US;
			else if (LocalMetadata["game"]["language"][i] == "ja-jp") Language |= ja_JP;
			else if (LocalMetadata["game"]["language"][i] == "ko-kr") Language |= ko_KR;
	}
	catch (...) {}
	if (Language == 0) return UnknownError;
	urlobj tempobj;
	bool loaded = false;
	try
	{
		tempobj.url = Diff["path"];
		tempobj.md5 = Diff["md5"];
		tempobj.filename = urlname(tempobj.url);
		ReturnList.push_back(tempobj);
		for (size_t i = 0; i < Diff["voice_packs"].size(); i++)
		{
			loaded = false;
			if ((Language & zh_CN) && Diff["voice_packs"][i]["language"] == "zh-cn")
			{
				tempobj.url = Diff["voice_packs"][i]["path"];
				tempobj.md5 = Diff["voice_packs"][i]["md5"];
				tempobj.filename = urlname(tempobj.url);
				loaded = true;
			}
			else if ((Language & en_US) && Diff["voice_packs"][i]["language"] == "en-us")
			{
				tempobj.url = Diff["voice_packs"][i]["path"];
				tempobj.md5 = Diff["voice_packs"][i]["md5"];
				tempobj.filename = urlname(tempobj.url);
				loaded = true;
			}
			else if ((Language & ja_JP) && Diff["voice_packs"][i]["language"] == "ja-jp")
			{
				tempobj.url = Diff["voice_packs"][i]["path"];
				tempobj.md5 = Diff["voice_packs"][i]["md5"];
				tempobj.filename = urlname(tempobj.url);
				loaded = true;
			}
			else if ((Language & ko_KR) && Diff["voice_packs"][i]["language"] == "ko-kr")
			{
				tempobj.url = Diff["voice_packs"][i]["path"];
				tempobj.md5 = Diff["voice_packs"][i]["md5"];
				tempobj.filename = urlname(tempobj.url);
				loaded = true;
			}
			if (loaded) ReturnList.push_back(tempobj);
		}
		return Success;
	}
	catch (...) {}
	return UnknownError;
}

bool GIAPI::Manager::StatInstalled() const
{
	if (!LocalMetadataStat) return false;
	try { if (LocalMetadata["game"]["status"] == true) return true; }
	catch (...) {}
	return false;
}

bool GIAPI::Manager::StatLatest(bool PreVer) const
{
	if (!LocalMetadataStat || !ResourceIndexStat) return false;
	try {
		if (PreVer)
		{
			if (LocalMetadata["game"]["version"] == ResourceIndex["data"]["pre_download_game"]["latest"]["version"])
				return true;
		}
		else
		{
			bool bLatest = false, bPreLatest = false;
			try {
				if (LocalMetadata["game"]["version"] == ResourceIndex["data"]["game"]["latest"]["version"])
					bLatest = true;
			}
			catch (...) {}
			bPreLatest = StatLatest(true);
			return (bLatest || bPreLatest);
		}
	}
	catch (...) {}
	return false;
}

bool GIAPI::Manager::StatPreDownload() const
{
	if (!ResourceIndexStat) return false;
	try { if (ResourceIndex["data"]["pre_download_game"] != nullptr) return true; }
	catch (...) {}
	return false;
}

GIAPI::ErrorCode GIAPI::Manager::GetInstallPath(string& ReturnPath)
{
	if (!LocalMetadataStat) return LocalMetadataNotLoaded;
	if (!StatInstalled()) return NotInstalled;
	try { ReturnPath = std::string(LocalMetadata["game"]["path"]); }
	catch (...) { return UnknownError; }
	return Success;
}

GIAPI::ErrorCode GIAPI::Manager::Install(strlist FileList, string Path, Server ServerId, int LanguageId)
{
	if (!ResourceIndexStat) return ResourceIndexNotLoaded;
	if (!LocalMetadataStat) return LocalMetadataNotLoaded;
	if (StatInstalled()) return NotInstalled;
	if (std::filesystem::exists(Path) && (!std::filesystem::is_directory(Path) || !std::filesystem::is_empty(Path))) return TargetPathNotSupported;
	std::filesystem::create_directories(Path);
	std::string serverId;
	switch (ServerId)
	{
	case GIAPI::CNREL_OFFICIAL:
		serverId = "cnrel_0";
		break;
	case GIAPI::CNREL_BILIBILI:
		serverId = "cnrel_1";
		break;
	case GIAPI::OSREL_GLOBAL:
		serverId = "osrel";
		break;
	default:
		return ServerIdNotSet;
		break;
	}
	try
	{
		bit7z::Bit7zLibrary lib("7z.dll");
		bit7z::BitFileExtractor ext(lib, bit7z::BitFormat::Zip);
		for (auto i : FileList) if (afc::match_tail(i, ".zip") || afc::match_tail(i, ".zip.001"))
			ext.extract(i, Path);
		LocalMetadata["game"]["entry"] = ResourceIndex["data"]["game"]["latest"]["entry"];
		LocalMetadata["game"]["path"] = afc::convert_string(std::filesystem::absolute(Path).wstring());
		LocalMetadata["game"]["server"] = serverId;
		LocalMetadata["game"]["status"] = true;
		LocalMetadata["game"]["version"] = ResourceIndex["data"]["game"]["latest"]["version"];
		if (LanguageId & zh_CN) LocalMetadata["game"]["language"].push_back("zh-cn");
		if (LanguageId & en_US) LocalMetadata["game"]["language"].push_back("en-us");
		if (LanguageId & ja_JP) LocalMetadata["game"]["language"].push_back("ja-jp");
		if (LanguageId & ko_KR) LocalMetadata["game"]["language"].push_back("ko-kr");
		FlushMetadata();
		std::string GPath = (std::filesystem::path(Path) / std::string(ResourceIndex["data"]["game"]["latest"]["entry"])).string();
		std::string SCPath = std::string(getenv("USERPROFILE")) + "\\Desktop\\" + SHORTCUT_NAME_NO_SUFFIX + ".lnk";
		AFC_CreateShortCutA(GPath.c_str(), SCPath.c_str());
		return Success;
	}
	catch (...) {}
	return UnknownError;
}

GIAPI::ErrorCode GIAPI::Manager::PreInstall(strlist FileList, string Path, Server ServerId, int LanguageId)
{
	if (!ResourceIndexStat) return ResourceIndexNotLoaded;
	if (!LocalMetadataStat) return LocalMetadataNotLoaded;
	if (StatInstalled()) return NotInstalled;
	if (std::filesystem::exists(Path) && (!std::filesystem::is_directory(Path) || !std::filesystem::is_empty(Path))) return TargetPathNotSupported;
	std::filesystem::create_directories(Path);
	std::string serverId;
	switch (ServerId)
	{
	case GIAPI::CNREL_OFFICIAL:
		serverId = "cnrel_0";
		break;
	case GIAPI::CNREL_BILIBILI:
		serverId = "cnrel_1";
		break;
	case GIAPI::OSREL_GLOBAL:
		serverId = "osrel";
		break;
	default:
		return ServerIdNotSet;
		break;
	}
	try
	{
		bit7z::Bit7zLibrary lib("7z.dll");
		bit7z::BitFileExtractor ext(lib, bit7z::BitFormat::Zip);
		for (auto i : FileList) if (afc::match_tail(i, ".zip") || afc::match_tail(i, ".zip.001"))
			ext.extract(i, Path);
		LocalMetadata["game"]["entry"] = ResourceIndex["data"]["pre_download_game"]["latest"]["entry"];
		LocalMetadata["game"]["path"] = afc::convert_string(std::filesystem::absolute(Path).wstring());
		LocalMetadata["game"]["server"] = serverId;
		LocalMetadata["game"]["status"] = true;
		LocalMetadata["game"]["version"] = ResourceIndex["data"]["pre_download_game"]["latest"]["version"];
		if (LanguageId & zh_CN) LocalMetadata["game"]["language"].push_back("zh-cn");
		if (LanguageId & en_US) LocalMetadata["game"]["language"].push_back("en-us");
		if (LanguageId & ja_JP) LocalMetadata["game"]["language"].push_back("ja-jp");
		if (LanguageId & ko_KR) LocalMetadata["game"]["language"].push_back("ko-kr");
		FlushMetadata();
		std::string GPath = (std::filesystem::path(Path) / std::string(ResourceIndex["data"]["pre_download_game"]["latest"]["entry"])).string();
		std::string SCPath = std::string(getenv("USERPROFILE")) + "\\Desktop\\" + SHORTCUT_NAME_NO_SUFFIX + ".lnk";
		AFC_CreateShortCutA(GPath.c_str(), SCPath.c_str());
		return Success;
	}
	catch (...) {}
	return UnknownError;
}

GIAPI::ErrorCode GIAPI::Manager::Update(strlist FileList)
{
	if (!ResourceIndexStat) return ResourceIndexNotLoaded;
	if (!LocalMetadataStat) return LocalMetadataNotLoaded;
	if (!StatInstalled()) return NotInstalled;
	if (StatLatest()) return AlreadyLatest;
	std::filesystem::path Path;
	try { Path = std::string(LocalMetadata["game"]["path"]); }
	catch (...) { return UnknownError; }
	std::filesystem::path TempPath = Path.parent_path() / "Genshin Impact Update";
	std::filesystem::create_directories(TempPath);
	std::fstream file;
	std::string tempstr;
	std::vector<std::string> dellist;
	try {
		bit7z::Bit7zLibrary lib("7z.dll");
		bit7z::BitFileExtractor ext(lib, bit7z::BitFormat::Zip);
		for (auto i : FileList)
		{
			if (afc::match_tail(i, ".zip") || afc::match_tail(i, ".zip.001"))
				ext.extract(i, TempPath.string());
			else continue;
			if (std::filesystem::exists(TempPath / "deletefiles.txt"))
			{
				file.open(TempPath / "deletefiles.txt", std::ios::in | std::ios::binary);
				if (!file.is_open()) throw "File: deletefiles.txt open failed.";
				while (!file.eof())
				{
					std::getline(file, tempstr);
					if (tempstr.empty()) continue;
					dellist.push_back((Path / tempstr).string());
				}
				file.close();
				std::filesystem::remove(TempPath / "deletefiles.txt");
			}
			if (std::filesystem::exists(TempPath / "hdifffiles.txt"))
			{
				file.open(TempPath / "hdifffiles.txt", std::ios::in | std::ios::binary);
				if (!file.is_open()) throw "File: hdifffiles.txt open failed.";
				while (!file.eof())
				{
					std::getline(file, tempstr);
					if (tempstr.empty()) continue;
					while (tempstr.back() == '\r') tempstr.pop_back();
					tempstr.pop_back();
					tempstr.pop_back();
					tempstr.erase(tempstr.begin(), tempstr.begin() + 16);
					hpatch((Path / tempstr).string().c_str(), (TempPath / (tempstr + ".hdiff")).string().c_str(), (TempPath / tempstr).string().c_str());
					std::filesystem::remove(TempPath / (tempstr + ".hdiff"));
				}
				file.close();
				std::filesystem::remove(TempPath / "hdifffiles.txt");
			}
		}
		for (auto i = dellist.begin(); i != dellist.end(); ++i)
		{
			while (i->back() == '\r') i->pop_back();
			std::filesystem::remove(*i);
		}
		afc::rename(TempPath, Path);
		LocalMetadata["game"]["version"] = ResourceIndex["data"]["game"]["latest"]["version"];
		FlushMetadata();
	}
	catch (...) {
		throw;
		file.close();
		std::filesystem::remove_all(TempPath);
		return UnknownError;
	}
	return Success;
}

GIAPI::ErrorCode GIAPI::Manager::PreUpdate(strlist FileList)
{
	if (!ResourceIndexStat) return ResourceIndexNotLoaded;
	if (!LocalMetadataStat) return LocalMetadataNotLoaded;
	if (!StatInstalled()) return NotInstalled;
	if (StatLatest(true)) return AlreadyLatest;
	std::filesystem::path Path;
	try { Path = std::string(LocalMetadata["game"]["path"]); }
	catch (...) { return UnknownError; }
	std::filesystem::path TempPath = Path.parent_path() / "Genshin Impact Update";
	std::filesystem::create_directories(TempPath);
	std::fstream file;
	std::string tempstr;
	std::vector<std::string> dellist;
	try {
		bit7z::Bit7zLibrary lib("7z.dll");
		bit7z::BitFileExtractor ext(lib, bit7z::BitFormat::Zip);
		for (auto i : FileList)
		{
			if (afc::match_tail(i, ".zip") || afc::match_tail(i, ".zip.001"))
				ext.extract(i, TempPath.string());
			else continue;
			if (std::filesystem::exists(TempPath / "deletefiles.txt"))
			{
				file.open(TempPath / "deletefiles.txt", std::ios::in | std::ios::binary);
				if (!file.is_open()) throw "File: deletefiles.txt open failed.";
				while (!file.eof())
				{
					std::getline(file, tempstr);
					if (tempstr.empty()) continue;
					dellist.push_back((Path / tempstr).string());
				}
				file.close();
				std::filesystem::remove(TempPath / "deletefiles.txt");
			}
			if (std::filesystem::exists(TempPath / "hdifffiles.txt"))
			{
				file.open(TempPath / "hdifffiles.txt", std::ios::in | std::ios::binary);
				if (!file.is_open()) throw "File: hdifffiles.txt open failed.";
				while (!file.eof())
				{
					std::getline(file, tempstr);
					if (tempstr.empty()) continue;
					while (tempstr.back() == '\r') tempstr.pop_back();
					tempstr.pop_back();
					tempstr.pop_back();
					tempstr.erase(tempstr.begin(), tempstr.begin() + 16);
					hpatch((Path / tempstr).string().c_str(), (TempPath / (tempstr + ".hdiff")).string().c_str(), (TempPath / tempstr).string().c_str());
					std::filesystem::remove(TempPath / (tempstr + ".hdiff"));
				}
				file.close();
				std::filesystem::remove(TempPath / "hdifffiles.txt");
			}
		}
		for (auto i = dellist.begin(); i != dellist.end(); ++i)
		{
			while (i->back() == '\r') i->pop_back();
			std::filesystem::remove(*i);
		}
		afc::rename(TempPath, Path);
		LocalMetadata["game"]["version"] = ResourceIndex["data"]["pre_download_game"]["latest"]["version"];
		FlushMetadata();
	}
	catch (...) {
		throw;
		file.close();
		std::filesystem::remove_all(TempPath);
		return UnknownError;
	}
	return Success;
}

GIAPI::ErrorCode GIAPI::Manager::Uninstall()
{
	if (!LocalMetadataStat) return LocalMetadataNotLoaded;
	if (!StatInstalled()) return NotInstalled;
	std::filesystem::remove_all(std::string(LocalMetadata["game"]["path"]));
	LocalMetadata["game"]["entry"] = std::string();
	LocalMetadata["game"]["path"] = std::string();
	LocalMetadata["game"]["status"] = false;
	LocalMetadata["game"]["version"] = std::string();
	FlushMetadata();
	return Success;
}

GIAPI::ErrorCode GIAPI::Manager::Launch() const
{
	if (!LocalMetadataStat) return LocalMetadataNotLoaded;
	if (!StatInstalled()) return NotInstalled;
	std::filesystem::path GamePath = std::string(LocalMetadata["game"]["path"]);
	GamePath /= std::string(LocalMetadata["game"]["entry"]);
	return ((INT_PTR)ShellExecuteW(nullptr, L"runas", GamePath.wstring().c_str(), nullptr, nullptr, SW_SHOWNORMAL) > 32) ? Success : UnknownError;
}

void GIAPI::Manager::FlushMetadata() const
{
	if (!LocalMetadataStat) return;
	std::fstream file(MetadataPath, std::ios::out | std::ios::binary | std::ios::trunc);
	if (!file.is_open()) return;
	try { file << LocalMetadata; /*printf("%s\n", "Save OK!");*/ }
	catch (...) {}
	file.close();
	return;
}
